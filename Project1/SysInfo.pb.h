// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SysInfo.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_SysInfo_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_SysInfo_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_SysInfo_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_SysInfo_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_SysInfo_2eproto;
class CPURequest;
struct CPURequestDefaultTypeInternal;
extern CPURequestDefaultTypeInternal _CPURequest_default_instance_;
class CPUResponse;
struct CPUResponseDefaultTypeInternal;
extern CPUResponseDefaultTypeInternal _CPUResponse_default_instance_;
class DiskInfo;
struct DiskInfoDefaultTypeInternal;
extern DiskInfoDefaultTypeInternal _DiskInfo_default_instance_;
class DiskRequest;
struct DiskRequestDefaultTypeInternal;
extern DiskRequestDefaultTypeInternal _DiskRequest_default_instance_;
class DiskResponse;
struct DiskResponseDefaultTypeInternal;
extern DiskResponseDefaultTypeInternal _DiskResponse_default_instance_;
class NetworkAdapterInfo;
struct NetworkAdapterInfoDefaultTypeInternal;
extern NetworkAdapterInfoDefaultTypeInternal _NetworkAdapterInfo_default_instance_;
class NetworkRequest;
struct NetworkRequestDefaultTypeInternal;
extern NetworkRequestDefaultTypeInternal _NetworkRequest_default_instance_;
class NetworkResponse;
struct NetworkResponseDefaultTypeInternal;
extern NetworkResponseDefaultTypeInternal _NetworkResponse_default_instance_;
class OsRequest;
struct OsRequestDefaultTypeInternal;
extern OsRequestDefaultTypeInternal _OsRequest_default_instance_;
class OsResponse;
struct OsResponseDefaultTypeInternal;
extern OsResponseDefaultTypeInternal _OsResponse_default_instance_;
class RAMRequest;
struct RAMRequestDefaultTypeInternal;
extern RAMRequestDefaultTypeInternal _RAMRequest_default_instance_;
class RAMResponse;
struct RAMResponseDefaultTypeInternal;
extern RAMResponseDefaultTypeInternal _RAMResponse_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google


// ===================================================================


// -------------------------------------------------------------------

class RAMResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RAMResponse) */ {
 public:
  inline RAMResponse() : RAMResponse(nullptr) {}
  ~RAMResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RAMResponse(::google::protobuf::internal::ConstantInitialized);

  inline RAMResponse(const RAMResponse& from)
      : RAMResponse(nullptr, from) {}
  RAMResponse(RAMResponse&& from) noexcept
    : RAMResponse() {
    *this = ::std::move(from);
  }

  inline RAMResponse& operator=(const RAMResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RAMResponse& operator=(RAMResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RAMResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RAMResponse* internal_default_instance() {
    return reinterpret_cast<const RAMResponse*>(
               &_RAMResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RAMResponse& a, RAMResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RAMResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RAMResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RAMResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RAMResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RAMResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RAMResponse& from) {
    RAMResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RAMResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "RAMResponse";
  }
  protected:
  explicit RAMResponse(::google::protobuf::Arena* arena);
  RAMResponse(::google::protobuf::Arena* arena, const RAMResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalRAMinGBFieldNumber = 1,
    kUsedRAMinGBFieldNumber = 2,
    kTotalRAMinMBFieldNumber = 3,
    kUsedRAMinMBFieldNumber = 4,
  };
  // int64 totalRAMinGB = 1;
  void clear_totalramingb() ;
  ::int64_t totalramingb() const;
  void set_totalramingb(::int64_t value);

  private:
  ::int64_t _internal_totalramingb() const;
  void _internal_set_totalramingb(::int64_t value);

  public:
  // int64 usedRAMinGB = 2;
  void clear_usedramingb() ;
  ::int64_t usedramingb() const;
  void set_usedramingb(::int64_t value);

  private:
  ::int64_t _internal_usedramingb() const;
  void _internal_set_usedramingb(::int64_t value);

  public:
  // int64 totalRAMinMB = 3;
  void clear_totalraminmb() ;
  ::int64_t totalraminmb() const;
  void set_totalraminmb(::int64_t value);

  private:
  ::int64_t _internal_totalraminmb() const;
  void _internal_set_totalraminmb(::int64_t value);

  public:
  // int64 usedRAMinMB = 4;
  void clear_usedraminmb() ;
  ::int64_t usedraminmb() const;
  void set_usedraminmb(::int64_t value);

  private:
  ::int64_t _internal_usedraminmb() const;
  void _internal_set_usedraminmb(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:RAMResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t totalramingb_;
    ::int64_t usedramingb_;
    ::int64_t totalraminmb_;
    ::int64_t usedraminmb_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SysInfo_2eproto;
};// -------------------------------------------------------------------

class RAMRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:RAMRequest) */ {
 public:
  inline RAMRequest() : RAMRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RAMRequest(::google::protobuf::internal::ConstantInitialized);

  inline RAMRequest(const RAMRequest& from)
      : RAMRequest(nullptr, from) {}
  RAMRequest(RAMRequest&& from) noexcept
    : RAMRequest() {
    *this = ::std::move(from);
  }

  inline RAMRequest& operator=(const RAMRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RAMRequest& operator=(RAMRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RAMRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RAMRequest* internal_default_instance() {
    return reinterpret_cast<const RAMRequest*>(
               &_RAMRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RAMRequest& a, RAMRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RAMRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RAMRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RAMRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RAMRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RAMRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RAMRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "RAMRequest";
  }
  protected:
  explicit RAMRequest(::google::protobuf::Arena* arena);
  RAMRequest(::google::protobuf::Arena* arena, const RAMRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RAMRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_SysInfo_2eproto;
};// -------------------------------------------------------------------

class OsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OsResponse) */ {
 public:
  inline OsResponse() : OsResponse(nullptr) {}
  ~OsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OsResponse(::google::protobuf::internal::ConstantInitialized);

  inline OsResponse(const OsResponse& from)
      : OsResponse(nullptr, from) {}
  OsResponse(OsResponse&& from) noexcept
    : OsResponse() {
    *this = ::std::move(from);
  }

  inline OsResponse& operator=(const OsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OsResponse& operator=(OsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OsResponse* internal_default_instance() {
    return reinterpret_cast<const OsResponse*>(
               &_OsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OsResponse& a, OsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OsResponse& from) {
    OsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "OsResponse";
  }
  protected:
  explicit OsResponse(::google::protobuf::Arena* arena);
  OsResponse(::google::protobuf::Arena* arena, const OsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsVirtualMachineFieldNumber = 1,
  };
  // string isVirtualMachine = 1;
  void clear_isvirtualmachine() ;
  const std::string& isvirtualmachine() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_isvirtualmachine(Arg_&& arg, Args_... args);
  std::string* mutable_isvirtualmachine();
  PROTOBUF_NODISCARD std::string* release_isvirtualmachine();
  void set_allocated_isvirtualmachine(std::string* value);

  private:
  const std::string& _internal_isvirtualmachine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_isvirtualmachine(
      const std::string& value);
  std::string* _internal_mutable_isvirtualmachine();

  public:
  // @@protoc_insertion_point(class_scope:OsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr isvirtualmachine_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SysInfo_2eproto;
};// -------------------------------------------------------------------

class OsRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:OsRequest) */ {
 public:
  inline OsRequest() : OsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OsRequest(::google::protobuf::internal::ConstantInitialized);

  inline OsRequest(const OsRequest& from)
      : OsRequest(nullptr, from) {}
  OsRequest(OsRequest&& from) noexcept
    : OsRequest() {
    *this = ::std::move(from);
  }

  inline OsRequest& operator=(const OsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OsRequest& operator=(OsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OsRequest* internal_default_instance() {
    return reinterpret_cast<const OsRequest*>(
               &_OsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OsRequest& a, OsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "OsRequest";
  }
  protected:
  explicit OsRequest(::google::protobuf::Arena* arena);
  OsRequest(::google::protobuf::Arena* arena, const OsRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:OsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_SysInfo_2eproto;
};// -------------------------------------------------------------------

class NetworkRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:NetworkRequest) */ {
 public:
  inline NetworkRequest() : NetworkRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkRequest(::google::protobuf::internal::ConstantInitialized);

  inline NetworkRequest(const NetworkRequest& from)
      : NetworkRequest(nullptr, from) {}
  NetworkRequest(NetworkRequest&& from) noexcept
    : NetworkRequest() {
    *this = ::std::move(from);
  }

  inline NetworkRequest& operator=(const NetworkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkRequest& operator=(NetworkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkRequest* internal_default_instance() {
    return reinterpret_cast<const NetworkRequest*>(
               &_NetworkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NetworkRequest& a, NetworkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NetworkRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NetworkRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NetworkRequest";
  }
  protected:
  explicit NetworkRequest(::google::protobuf::Arena* arena);
  NetworkRequest(::google::protobuf::Arena* arena, const NetworkRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NetworkRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_SysInfo_2eproto;
};// -------------------------------------------------------------------

class NetworkAdapterInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetworkAdapterInfo) */ {
 public:
  inline NetworkAdapterInfo() : NetworkAdapterInfo(nullptr) {}
  ~NetworkAdapterInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkAdapterInfo(::google::protobuf::internal::ConstantInitialized);

  inline NetworkAdapterInfo(const NetworkAdapterInfo& from)
      : NetworkAdapterInfo(nullptr, from) {}
  NetworkAdapterInfo(NetworkAdapterInfo&& from) noexcept
    : NetworkAdapterInfo() {
    *this = ::std::move(from);
  }

  inline NetworkAdapterInfo& operator=(const NetworkAdapterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkAdapterInfo& operator=(NetworkAdapterInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkAdapterInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkAdapterInfo* internal_default_instance() {
    return reinterpret_cast<const NetworkAdapterInfo*>(
               &_NetworkAdapterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NetworkAdapterInfo& a, NetworkAdapterInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkAdapterInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkAdapterInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkAdapterInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkAdapterInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NetworkAdapterInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NetworkAdapterInfo& from) {
    NetworkAdapterInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NetworkAdapterInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NetworkAdapterInfo";
  }
  protected:
  explicit NetworkAdapterInfo(::google::protobuf::Arena* arena);
  NetworkAdapterInfo(::google::protobuf::Arena* arena, const NetworkAdapterInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendlyNameFieldNumber = 1,
    kAdapterDescFieldNumber = 2,
    kIpAddressFieldNumber = 3,
    kIpMaskFieldNumber = 4,
    kGatewayFieldNumber = 5,
    kDhcpServerFieldNumber = 6,
  };
  // string friendly_name = 1;
  void clear_friendly_name() ;
  const std::string& friendly_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_friendly_name(Arg_&& arg, Args_... args);
  std::string* mutable_friendly_name();
  PROTOBUF_NODISCARD std::string* release_friendly_name();
  void set_allocated_friendly_name(std::string* value);

  private:
  const std::string& _internal_friendly_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_friendly_name(
      const std::string& value);
  std::string* _internal_mutable_friendly_name();

  public:
  // string Adapter_Desc = 2;
  void clear_adapter_desc() ;
  const std::string& adapter_desc() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_adapter_desc(Arg_&& arg, Args_... args);
  std::string* mutable_adapter_desc();
  PROTOBUF_NODISCARD std::string* release_adapter_desc();
  void set_allocated_adapter_desc(std::string* value);

  private:
  const std::string& _internal_adapter_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adapter_desc(
      const std::string& value);
  std::string* _internal_mutable_adapter_desc();

  public:
  // string ip_address = 3;
  void clear_ip_address() ;
  const std::string& ip_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* value);

  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(
      const std::string& value);
  std::string* _internal_mutable_ip_address();

  public:
  // string ip_mask = 4;
  void clear_ip_mask() ;
  const std::string& ip_mask() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_mask(Arg_&& arg, Args_... args);
  std::string* mutable_ip_mask();
  PROTOBUF_NODISCARD std::string* release_ip_mask();
  void set_allocated_ip_mask(std::string* value);

  private:
  const std::string& _internal_ip_mask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_mask(
      const std::string& value);
  std::string* _internal_mutable_ip_mask();

  public:
  // string gateway = 5;
  void clear_gateway() ;
  const std::string& gateway() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gateway(Arg_&& arg, Args_... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* value);

  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(
      const std::string& value);
  std::string* _internal_mutable_gateway();

  public:
  // string dhcp_server = 6;
  void clear_dhcp_server() ;
  const std::string& dhcp_server() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dhcp_server(Arg_&& arg, Args_... args);
  std::string* mutable_dhcp_server();
  PROTOBUF_NODISCARD std::string* release_dhcp_server();
  void set_allocated_dhcp_server(std::string* value);

  private:
  const std::string& _internal_dhcp_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dhcp_server(
      const std::string& value);
  std::string* _internal_mutable_dhcp_server();

  public:
  // @@protoc_insertion_point(class_scope:NetworkAdapterInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      87, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr friendly_name_;
    ::google::protobuf::internal::ArenaStringPtr adapter_desc_;
    ::google::protobuf::internal::ArenaStringPtr ip_address_;
    ::google::protobuf::internal::ArenaStringPtr ip_mask_;
    ::google::protobuf::internal::ArenaStringPtr gateway_;
    ::google::protobuf::internal::ArenaStringPtr dhcp_server_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SysInfo_2eproto;
};// -------------------------------------------------------------------

class DiskRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DiskRequest) */ {
 public:
  inline DiskRequest() : DiskRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DiskRequest(::google::protobuf::internal::ConstantInitialized);

  inline DiskRequest(const DiskRequest& from)
      : DiskRequest(nullptr, from) {}
  DiskRequest(DiskRequest&& from) noexcept
    : DiskRequest() {
    *this = ::std::move(from);
  }

  inline DiskRequest& operator=(const DiskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskRequest& operator=(DiskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskRequest* internal_default_instance() {
    return reinterpret_cast<const DiskRequest*>(
               &_DiskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DiskRequest& a, DiskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DiskRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DiskRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DiskRequest";
  }
  protected:
  explicit DiskRequest(::google::protobuf::Arena* arena);
  DiskRequest(::google::protobuf::Arena* arena, const DiskRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DiskRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_SysInfo_2eproto;
};// -------------------------------------------------------------------

class DiskInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DiskInfo) */ {
 public:
  inline DiskInfo() : DiskInfo(nullptr) {}
  ~DiskInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DiskInfo(::google::protobuf::internal::ConstantInitialized);

  inline DiskInfo(const DiskInfo& from)
      : DiskInfo(nullptr, from) {}
  DiskInfo(DiskInfo&& from) noexcept
    : DiskInfo() {
    *this = ::std::move(from);
  }

  inline DiskInfo& operator=(const DiskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskInfo& operator=(DiskInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskInfo* internal_default_instance() {
    return reinterpret_cast<const DiskInfo*>(
               &_DiskInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DiskInfo& a, DiskInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiskInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DiskInfo& from) {
    DiskInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DiskInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DiskInfo";
  }
  protected:
  explicit DiskInfo(::google::protobuf::Arena* arena);
  DiskInfo(::google::protobuf::Arena* arena, const DiskInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kTotalsizeFieldNumber = 2,
    kUsedspaceFieldNumber = 3,
    kFreespaceFieldNumber = 4,
    kUsedpercentFieldNumber = 5,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // int64 totalsize = 2;
  void clear_totalsize() ;
  ::int64_t totalsize() const;
  void set_totalsize(::int64_t value);

  private:
  ::int64_t _internal_totalsize() const;
  void _internal_set_totalsize(::int64_t value);

  public:
  // int64 usedspace = 3;
  void clear_usedspace() ;
  ::int64_t usedspace() const;
  void set_usedspace(::int64_t value);

  private:
  ::int64_t _internal_usedspace() const;
  void _internal_set_usedspace(::int64_t value);

  public:
  // int64 freespace = 4;
  void clear_freespace() ;
  ::int64_t freespace() const;
  void set_freespace(::int64_t value);

  private:
  ::int64_t _internal_freespace() const;
  void _internal_set_freespace(::int64_t value);

  public:
  // int64 usedpercent = 5;
  void clear_usedpercent() ;
  ::int64_t usedpercent() const;
  void set_usedpercent(::int64_t value);

  private:
  ::int64_t _internal_usedpercent() const;
  void _internal_set_usedpercent(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:DiskInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      21, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::int64_t totalsize_;
    ::int64_t usedspace_;
    ::int64_t freespace_;
    ::int64_t usedpercent_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SysInfo_2eproto;
};// -------------------------------------------------------------------

class CPUResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CPUResponse) */ {
 public:
  inline CPUResponse() : CPUResponse(nullptr) {}
  ~CPUResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CPUResponse(::google::protobuf::internal::ConstantInitialized);

  inline CPUResponse(const CPUResponse& from)
      : CPUResponse(nullptr, from) {}
  CPUResponse(CPUResponse&& from) noexcept
    : CPUResponse() {
    *this = ::std::move(from);
  }

  inline CPUResponse& operator=(const CPUResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPUResponse& operator=(CPUResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CPUResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPUResponse* internal_default_instance() {
    return reinterpret_cast<const CPUResponse*>(
               &_CPUResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CPUResponse& a, CPUResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CPUResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPUResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CPUResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CPUResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CPUResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CPUResponse& from) {
    CPUResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CPUResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CPUResponse";
  }
  protected:
  explicit CPUResponse(::google::protobuf::Arena* arena);
  CPUResponse(::google::protobuf::Arena* arena, const CPUResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvgCPUusageFieldNumber = 1,
  };
  // int64 avgCPUusage = 1;
  void clear_avgcpuusage() ;
  ::int64_t avgcpuusage() const;
  void set_avgcpuusage(::int64_t value);

  private:
  ::int64_t _internal_avgcpuusage() const;
  void _internal_set_avgcpuusage(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:CPUResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t avgcpuusage_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SysInfo_2eproto;
};// -------------------------------------------------------------------

class CPURequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CPURequest) */ {
 public:
  inline CPURequest() : CPURequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CPURequest(::google::protobuf::internal::ConstantInitialized);

  inline CPURequest(const CPURequest& from)
      : CPURequest(nullptr, from) {}
  CPURequest(CPURequest&& from) noexcept
    : CPURequest() {
    *this = ::std::move(from);
  }

  inline CPURequest& operator=(const CPURequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPURequest& operator=(CPURequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CPURequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPURequest* internal_default_instance() {
    return reinterpret_cast<const CPURequest*>(
               &_CPURequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CPURequest& a, CPURequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CPURequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPURequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CPURequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CPURequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CPURequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CPURequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CPURequest";
  }
  protected:
  explicit CPURequest(::google::protobuf::Arena* arena);
  CPURequest(::google::protobuf::Arena* arena, const CPURequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CPURequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_SysInfo_2eproto;
};// -------------------------------------------------------------------

class NetworkResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetworkResponse) */ {
 public:
  inline NetworkResponse() : NetworkResponse(nullptr) {}
  ~NetworkResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetworkResponse(::google::protobuf::internal::ConstantInitialized);

  inline NetworkResponse(const NetworkResponse& from)
      : NetworkResponse(nullptr, from) {}
  NetworkResponse(NetworkResponse&& from) noexcept
    : NetworkResponse() {
    *this = ::std::move(from);
  }

  inline NetworkResponse& operator=(const NetworkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkResponse& operator=(NetworkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkResponse* internal_default_instance() {
    return reinterpret_cast<const NetworkResponse*>(
               &_NetworkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NetworkResponse& a, NetworkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NetworkResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NetworkResponse& from) {
    NetworkResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NetworkResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "NetworkResponse";
  }
  protected:
  explicit NetworkResponse(::google::protobuf::Arena* arena);
  NetworkResponse(::google::protobuf::Arena* arena, const NetworkResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworksAdapterFieldNumber = 1,
  };
  // repeated .NetworkAdapterInfo networks_adapter = 1;
  int networks_adapter_size() const;
  private:
  int _internal_networks_adapter_size() const;

  public:
  void clear_networks_adapter() ;
  ::NetworkAdapterInfo* mutable_networks_adapter(int index);
  ::google::protobuf::RepeatedPtrField< ::NetworkAdapterInfo >*
      mutable_networks_adapter();
  private:
  const ::google::protobuf::RepeatedPtrField<::NetworkAdapterInfo>& _internal_networks_adapter() const;
  ::google::protobuf::RepeatedPtrField<::NetworkAdapterInfo>* _internal_mutable_networks_adapter();
  public:
  const ::NetworkAdapterInfo& networks_adapter(int index) const;
  ::NetworkAdapterInfo* add_networks_adapter();
  const ::google::protobuf::RepeatedPtrField< ::NetworkAdapterInfo >&
      networks_adapter() const;
  // @@protoc_insertion_point(class_scope:NetworkResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::NetworkAdapterInfo > networks_adapter_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SysInfo_2eproto;
};// -------------------------------------------------------------------

class DiskResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DiskResponse) */ {
 public:
  inline DiskResponse() : DiskResponse(nullptr) {}
  ~DiskResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DiskResponse(::google::protobuf::internal::ConstantInitialized);

  inline DiskResponse(const DiskResponse& from)
      : DiskResponse(nullptr, from) {}
  DiskResponse(DiskResponse&& from) noexcept
    : DiskResponse() {
    *this = ::std::move(from);
  }

  inline DiskResponse& operator=(const DiskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskResponse& operator=(DiskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskResponse* internal_default_instance() {
    return reinterpret_cast<const DiskResponse*>(
               &_DiskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DiskResponse& a, DiskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiskResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DiskResponse& from) {
    DiskResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DiskResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "DiskResponse";
  }
  protected:
  explicit DiskResponse(::google::protobuf::Arena* arena);
  DiskResponse(::google::protobuf::Arena* arena, const DiskResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrivesFieldNumber = 1,
  };
  // repeated .DiskInfo drives = 1;
  int drives_size() const;
  private:
  int _internal_drives_size() const;

  public:
  void clear_drives() ;
  ::DiskInfo* mutable_drives(int index);
  ::google::protobuf::RepeatedPtrField< ::DiskInfo >*
      mutable_drives();
  private:
  const ::google::protobuf::RepeatedPtrField<::DiskInfo>& _internal_drives() const;
  ::google::protobuf::RepeatedPtrField<::DiskInfo>* _internal_mutable_drives();
  public:
  const ::DiskInfo& drives(int index) const;
  ::DiskInfo* add_drives();
  const ::google::protobuf::RepeatedPtrField< ::DiskInfo >&
      drives() const;
  // @@protoc_insertion_point(class_scope:DiskResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::DiskInfo > drives_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SysInfo_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// OsResponse

// string isVirtualMachine = 1;
inline void OsResponse::clear_isvirtualmachine() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isvirtualmachine_.ClearToEmpty();
}
inline const std::string& OsResponse::isvirtualmachine() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:OsResponse.isVirtualMachine)
  return _internal_isvirtualmachine();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OsResponse::set_isvirtualmachine(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.isvirtualmachine_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:OsResponse.isVirtualMachine)
}
inline std::string* OsResponse::mutable_isvirtualmachine() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_isvirtualmachine();
  // @@protoc_insertion_point(field_mutable:OsResponse.isVirtualMachine)
  return _s;
}
inline const std::string& OsResponse::_internal_isvirtualmachine() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isvirtualmachine_.Get();
}
inline void OsResponse::_internal_set_isvirtualmachine(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.isvirtualmachine_.Set(value, GetArena());
}
inline std::string* OsResponse::_internal_mutable_isvirtualmachine() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.isvirtualmachine_.Mutable( GetArena());
}
inline std::string* OsResponse::release_isvirtualmachine() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:OsResponse.isVirtualMachine)
  return _impl_.isvirtualmachine_.Release();
}
inline void OsResponse::set_allocated_isvirtualmachine(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isvirtualmachine_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.isvirtualmachine_.IsDefault()) {
          _impl_.isvirtualmachine_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OsResponse.isVirtualMachine)
}

// -------------------------------------------------------------------

// OsRequest

// -------------------------------------------------------------------

// NetworkAdapterInfo

// string friendly_name = 1;
inline void NetworkAdapterInfo::clear_friendly_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.friendly_name_.ClearToEmpty();
}
inline const std::string& NetworkAdapterInfo::friendly_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NetworkAdapterInfo.friendly_name)
  return _internal_friendly_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkAdapterInfo::set_friendly_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.friendly_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NetworkAdapterInfo.friendly_name)
}
inline std::string* NetworkAdapterInfo::mutable_friendly_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_friendly_name();
  // @@protoc_insertion_point(field_mutable:NetworkAdapterInfo.friendly_name)
  return _s;
}
inline const std::string& NetworkAdapterInfo::_internal_friendly_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.friendly_name_.Get();
}
inline void NetworkAdapterInfo::_internal_set_friendly_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.friendly_name_.Set(value, GetArena());
}
inline std::string* NetworkAdapterInfo::_internal_mutable_friendly_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.friendly_name_.Mutable( GetArena());
}
inline std::string* NetworkAdapterInfo::release_friendly_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NetworkAdapterInfo.friendly_name)
  return _impl_.friendly_name_.Release();
}
inline void NetworkAdapterInfo::set_allocated_friendly_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.friendly_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.friendly_name_.IsDefault()) {
          _impl_.friendly_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkAdapterInfo.friendly_name)
}

// string Adapter_Desc = 2;
inline void NetworkAdapterInfo::clear_adapter_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.adapter_desc_.ClearToEmpty();
}
inline const std::string& NetworkAdapterInfo::adapter_desc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NetworkAdapterInfo.Adapter_Desc)
  return _internal_adapter_desc();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkAdapterInfo::set_adapter_desc(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.adapter_desc_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NetworkAdapterInfo.Adapter_Desc)
}
inline std::string* NetworkAdapterInfo::mutable_adapter_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_adapter_desc();
  // @@protoc_insertion_point(field_mutable:NetworkAdapterInfo.Adapter_Desc)
  return _s;
}
inline const std::string& NetworkAdapterInfo::_internal_adapter_desc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.adapter_desc_.Get();
}
inline void NetworkAdapterInfo::_internal_set_adapter_desc(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.adapter_desc_.Set(value, GetArena());
}
inline std::string* NetworkAdapterInfo::_internal_mutable_adapter_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.adapter_desc_.Mutable( GetArena());
}
inline std::string* NetworkAdapterInfo::release_adapter_desc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NetworkAdapterInfo.Adapter_Desc)
  return _impl_.adapter_desc_.Release();
}
inline void NetworkAdapterInfo::set_allocated_adapter_desc(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.adapter_desc_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.adapter_desc_.IsDefault()) {
          _impl_.adapter_desc_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkAdapterInfo.Adapter_Desc)
}

// string ip_address = 3;
inline void NetworkAdapterInfo::clear_ip_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& NetworkAdapterInfo::ip_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NetworkAdapterInfo.ip_address)
  return _internal_ip_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkAdapterInfo::set_ip_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NetworkAdapterInfo.ip_address)
}
inline std::string* NetworkAdapterInfo::mutable_ip_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:NetworkAdapterInfo.ip_address)
  return _s;
}
inline const std::string& NetworkAdapterInfo::_internal_ip_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_address_.Get();
}
inline void NetworkAdapterInfo::_internal_set_ip_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_address_.Set(value, GetArena());
}
inline std::string* NetworkAdapterInfo::_internal_mutable_ip_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_address_.Mutable( GetArena());
}
inline std::string* NetworkAdapterInfo::release_ip_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NetworkAdapterInfo.ip_address)
  return _impl_.ip_address_.Release();
}
inline void NetworkAdapterInfo::set_allocated_ip_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_address_.IsDefault()) {
          _impl_.ip_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkAdapterInfo.ip_address)
}

// string ip_mask = 4;
inline void NetworkAdapterInfo::clear_ip_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_mask_.ClearToEmpty();
}
inline const std::string& NetworkAdapterInfo::ip_mask() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NetworkAdapterInfo.ip_mask)
  return _internal_ip_mask();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkAdapterInfo::set_ip_mask(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_mask_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NetworkAdapterInfo.ip_mask)
}
inline std::string* NetworkAdapterInfo::mutable_ip_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip_mask();
  // @@protoc_insertion_point(field_mutable:NetworkAdapterInfo.ip_mask)
  return _s;
}
inline const std::string& NetworkAdapterInfo::_internal_ip_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_mask_.Get();
}
inline void NetworkAdapterInfo::_internal_set_ip_mask(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_mask_.Set(value, GetArena());
}
inline std::string* NetworkAdapterInfo::_internal_mutable_ip_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_mask_.Mutable( GetArena());
}
inline std::string* NetworkAdapterInfo::release_ip_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NetworkAdapterInfo.ip_mask)
  return _impl_.ip_mask_.Release();
}
inline void NetworkAdapterInfo::set_allocated_ip_mask(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_mask_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_mask_.IsDefault()) {
          _impl_.ip_mask_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkAdapterInfo.ip_mask)
}

// string gateway = 5;
inline void NetworkAdapterInfo::clear_gateway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gateway_.ClearToEmpty();
}
inline const std::string& NetworkAdapterInfo::gateway() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NetworkAdapterInfo.gateway)
  return _internal_gateway();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkAdapterInfo::set_gateway(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gateway_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NetworkAdapterInfo.gateway)
}
inline std::string* NetworkAdapterInfo::mutable_gateway() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:NetworkAdapterInfo.gateway)
  return _s;
}
inline const std::string& NetworkAdapterInfo::_internal_gateway() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gateway_.Get();
}
inline void NetworkAdapterInfo::_internal_set_gateway(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gateway_.Set(value, GetArena());
}
inline std::string* NetworkAdapterInfo::_internal_mutable_gateway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.gateway_.Mutable( GetArena());
}
inline std::string* NetworkAdapterInfo::release_gateway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NetworkAdapterInfo.gateway)
  return _impl_.gateway_.Release();
}
inline void NetworkAdapterInfo::set_allocated_gateway(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gateway_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gateway_.IsDefault()) {
          _impl_.gateway_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkAdapterInfo.gateway)
}

// string dhcp_server = 6;
inline void NetworkAdapterInfo::clear_dhcp_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dhcp_server_.ClearToEmpty();
}
inline const std::string& NetworkAdapterInfo::dhcp_server() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NetworkAdapterInfo.dhcp_server)
  return _internal_dhcp_server();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetworkAdapterInfo::set_dhcp_server(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dhcp_server_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:NetworkAdapterInfo.dhcp_server)
}
inline std::string* NetworkAdapterInfo::mutable_dhcp_server() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dhcp_server();
  // @@protoc_insertion_point(field_mutable:NetworkAdapterInfo.dhcp_server)
  return _s;
}
inline const std::string& NetworkAdapterInfo::_internal_dhcp_server() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dhcp_server_.Get();
}
inline void NetworkAdapterInfo::_internal_set_dhcp_server(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dhcp_server_.Set(value, GetArena());
}
inline std::string* NetworkAdapterInfo::_internal_mutable_dhcp_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.dhcp_server_.Mutable( GetArena());
}
inline std::string* NetworkAdapterInfo::release_dhcp_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:NetworkAdapterInfo.dhcp_server)
  return _impl_.dhcp_server_.Release();
}
inline void NetworkAdapterInfo::set_allocated_dhcp_server(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dhcp_server_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dhcp_server_.IsDefault()) {
          _impl_.dhcp_server_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkAdapterInfo.dhcp_server)
}

// -------------------------------------------------------------------

// NetworkResponse

// repeated .NetworkAdapterInfo networks_adapter = 1;
inline int NetworkResponse::_internal_networks_adapter_size() const {
  return _internal_networks_adapter().size();
}
inline int NetworkResponse::networks_adapter_size() const {
  return _internal_networks_adapter_size();
}
inline void NetworkResponse::clear_networks_adapter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.networks_adapter_.Clear();
}
inline ::NetworkAdapterInfo* NetworkResponse::mutable_networks_adapter(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:NetworkResponse.networks_adapter)
  return _internal_mutable_networks_adapter()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::NetworkAdapterInfo>* NetworkResponse::mutable_networks_adapter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:NetworkResponse.networks_adapter)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_networks_adapter();
}
inline const ::NetworkAdapterInfo& NetworkResponse::networks_adapter(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:NetworkResponse.networks_adapter)
  return _internal_networks_adapter().Get(index);
}
inline ::NetworkAdapterInfo* NetworkResponse::add_networks_adapter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::NetworkAdapterInfo* _add = _internal_mutable_networks_adapter()->Add();
  // @@protoc_insertion_point(field_add:NetworkResponse.networks_adapter)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::NetworkAdapterInfo>& NetworkResponse::networks_adapter() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:NetworkResponse.networks_adapter)
  return _internal_networks_adapter();
}
inline const ::google::protobuf::RepeatedPtrField<::NetworkAdapterInfo>&
NetworkResponse::_internal_networks_adapter() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.networks_adapter_;
}
inline ::google::protobuf::RepeatedPtrField<::NetworkAdapterInfo>*
NetworkResponse::_internal_mutable_networks_adapter() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.networks_adapter_;
}

// -------------------------------------------------------------------

// NetworkRequest

// -------------------------------------------------------------------

// DiskInfo

// string path = 1;
inline void DiskInfo::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& DiskInfo::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DiskInfo.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DiskInfo::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DiskInfo.path)
}
inline std::string* DiskInfo::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:DiskInfo.path)
  return _s;
}
inline const std::string& DiskInfo::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void DiskInfo::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* DiskInfo::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* DiskInfo::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DiskInfo.path)
  return _impl_.path_.Release();
}
inline void DiskInfo::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DiskInfo.path)
}

// int64 totalsize = 2;
inline void DiskInfo::clear_totalsize() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalsize_ = ::int64_t{0};
}
inline ::int64_t DiskInfo::totalsize() const {
  // @@protoc_insertion_point(field_get:DiskInfo.totalsize)
  return _internal_totalsize();
}
inline void DiskInfo::set_totalsize(::int64_t value) {
  _internal_set_totalsize(value);
  // @@protoc_insertion_point(field_set:DiskInfo.totalsize)
}
inline ::int64_t DiskInfo::_internal_totalsize() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.totalsize_;
}
inline void DiskInfo::_internal_set_totalsize(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.totalsize_ = value;
}

// int64 usedspace = 3;
inline void DiskInfo::clear_usedspace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usedspace_ = ::int64_t{0};
}
inline ::int64_t DiskInfo::usedspace() const {
  // @@protoc_insertion_point(field_get:DiskInfo.usedspace)
  return _internal_usedspace();
}
inline void DiskInfo::set_usedspace(::int64_t value) {
  _internal_set_usedspace(value);
  // @@protoc_insertion_point(field_set:DiskInfo.usedspace)
}
inline ::int64_t DiskInfo::_internal_usedspace() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usedspace_;
}
inline void DiskInfo::_internal_set_usedspace(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.usedspace_ = value;
}

// int64 freespace = 4;
inline void DiskInfo::clear_freespace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.freespace_ = ::int64_t{0};
}
inline ::int64_t DiskInfo::freespace() const {
  // @@protoc_insertion_point(field_get:DiskInfo.freespace)
  return _internal_freespace();
}
inline void DiskInfo::set_freespace(::int64_t value) {
  _internal_set_freespace(value);
  // @@protoc_insertion_point(field_set:DiskInfo.freespace)
}
inline ::int64_t DiskInfo::_internal_freespace() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.freespace_;
}
inline void DiskInfo::_internal_set_freespace(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.freespace_ = value;
}

// int64 usedpercent = 5;
inline void DiskInfo::clear_usedpercent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usedpercent_ = ::int64_t{0};
}
inline ::int64_t DiskInfo::usedpercent() const {
  // @@protoc_insertion_point(field_get:DiskInfo.usedpercent)
  return _internal_usedpercent();
}
inline void DiskInfo::set_usedpercent(::int64_t value) {
  _internal_set_usedpercent(value);
  // @@protoc_insertion_point(field_set:DiskInfo.usedpercent)
}
inline ::int64_t DiskInfo::_internal_usedpercent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usedpercent_;
}
inline void DiskInfo::_internal_set_usedpercent(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.usedpercent_ = value;
}

// -------------------------------------------------------------------

// DiskResponse

// repeated .DiskInfo drives = 1;
inline int DiskResponse::_internal_drives_size() const {
  return _internal_drives().size();
}
inline int DiskResponse::drives_size() const {
  return _internal_drives_size();
}
inline void DiskResponse::clear_drives() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.drives_.Clear();
}
inline ::DiskInfo* DiskResponse::mutable_drives(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DiskResponse.drives)
  return _internal_mutable_drives()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DiskInfo>* DiskResponse::mutable_drives()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DiskResponse.drives)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_drives();
}
inline const ::DiskInfo& DiskResponse::drives(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DiskResponse.drives)
  return _internal_drives().Get(index);
}
inline ::DiskInfo* DiskResponse::add_drives() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DiskInfo* _add = _internal_mutable_drives()->Add();
  // @@protoc_insertion_point(field_add:DiskResponse.drives)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DiskInfo>& DiskResponse::drives() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DiskResponse.drives)
  return _internal_drives();
}
inline const ::google::protobuf::RepeatedPtrField<::DiskInfo>&
DiskResponse::_internal_drives() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.drives_;
}
inline ::google::protobuf::RepeatedPtrField<::DiskInfo>*
DiskResponse::_internal_mutable_drives() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.drives_;
}

// -------------------------------------------------------------------

// DiskRequest

// -------------------------------------------------------------------

// RAMRequest

// -------------------------------------------------------------------

// RAMResponse

// int64 totalRAMinGB = 1;
inline void RAMResponse::clear_totalramingb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalramingb_ = ::int64_t{0};
}
inline ::int64_t RAMResponse::totalramingb() const {
  // @@protoc_insertion_point(field_get:RAMResponse.totalRAMinGB)
  return _internal_totalramingb();
}
inline void RAMResponse::set_totalramingb(::int64_t value) {
  _internal_set_totalramingb(value);
  // @@protoc_insertion_point(field_set:RAMResponse.totalRAMinGB)
}
inline ::int64_t RAMResponse::_internal_totalramingb() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.totalramingb_;
}
inline void RAMResponse::_internal_set_totalramingb(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.totalramingb_ = value;
}

// int64 usedRAMinGB = 2;
inline void RAMResponse::clear_usedramingb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usedramingb_ = ::int64_t{0};
}
inline ::int64_t RAMResponse::usedramingb() const {
  // @@protoc_insertion_point(field_get:RAMResponse.usedRAMinGB)
  return _internal_usedramingb();
}
inline void RAMResponse::set_usedramingb(::int64_t value) {
  _internal_set_usedramingb(value);
  // @@protoc_insertion_point(field_set:RAMResponse.usedRAMinGB)
}
inline ::int64_t RAMResponse::_internal_usedramingb() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usedramingb_;
}
inline void RAMResponse::_internal_set_usedramingb(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.usedramingb_ = value;
}

// int64 totalRAMinMB = 3;
inline void RAMResponse::clear_totalraminmb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalraminmb_ = ::int64_t{0};
}
inline ::int64_t RAMResponse::totalraminmb() const {
  // @@protoc_insertion_point(field_get:RAMResponse.totalRAMinMB)
  return _internal_totalraminmb();
}
inline void RAMResponse::set_totalraminmb(::int64_t value) {
  _internal_set_totalraminmb(value);
  // @@protoc_insertion_point(field_set:RAMResponse.totalRAMinMB)
}
inline ::int64_t RAMResponse::_internal_totalraminmb() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.totalraminmb_;
}
inline void RAMResponse::_internal_set_totalraminmb(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.totalraminmb_ = value;
}

// int64 usedRAMinMB = 4;
inline void RAMResponse::clear_usedraminmb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usedraminmb_ = ::int64_t{0};
}
inline ::int64_t RAMResponse::usedraminmb() const {
  // @@protoc_insertion_point(field_get:RAMResponse.usedRAMinMB)
  return _internal_usedraminmb();
}
inline void RAMResponse::set_usedraminmb(::int64_t value) {
  _internal_set_usedraminmb(value);
  // @@protoc_insertion_point(field_set:RAMResponse.usedRAMinMB)
}
inline ::int64_t RAMResponse::_internal_usedraminmb() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usedraminmb_;
}
inline void RAMResponse::_internal_set_usedraminmb(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.usedraminmb_ = value;
}

// -------------------------------------------------------------------

// CPURequest

// -------------------------------------------------------------------

// CPUResponse

// int64 avgCPUusage = 1;
inline void CPUResponse::clear_avgcpuusage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.avgcpuusage_ = ::int64_t{0};
}
inline ::int64_t CPUResponse::avgcpuusage() const {
  // @@protoc_insertion_point(field_get:CPUResponse.avgCPUusage)
  return _internal_avgcpuusage();
}
inline void CPUResponse::set_avgcpuusage(::int64_t value) {
  _internal_set_avgcpuusage(value);
  // @@protoc_insertion_point(field_set:CPUResponse.avgCPUusage)
}
inline ::int64_t CPUResponse::_internal_avgcpuusage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.avgcpuusage_;
}
inline void CPUResponse::_internal_set_avgcpuusage(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.avgcpuusage_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_SysInfo_2eproto_2epb_2eh
